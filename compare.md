# การเลือกใช้ระหว่าง **RabbitMQ** และ **Apache Kafka** 

เป็นคำถามคลาสสิกในโลกของ System Design ทั้งคู่เป็นเครื่องมือสำหรับจัดการข้อมูลแบบ Asynchronous (Messaging System) เหมือนกัน แต่มีสถาปัตยกรรมและจุดประสงค์ที่ต่างกันอย่างชัดเจนครับ

สรุปสั้นๆ คือ: **RabbitMQ** เป็น "Traditional Message Broker" ที่เก่งเรื่องการจัดการคิวที่ซับซ้อน ส่วน **Kafka** เป็น "Event Streaming Platform" ที่เก่งเรื่องการจัดการข้อมูลปริมาณมหาศาล (Big Data)

นี่คือตารางเปรียบเทียบเจาะลึกครับ:

-----

### 1\. ตารางเปรียบเทียบ (Quick Comparison)

| หัวข้อ | RabbitMQ | Apache Kafka |
| :--- | :--- | :--- |
| **ประเภท** | Message Broker (เน้นคิว) | Event Streaming Platform (เน้น Log) |
| **สถาปัตยกรรม** | **Smart Broker / Dumb Consumer** <br>(ตัวกลางฉลาด จัดการ Routing ให้) | **Dumb Broker / Smart Consumer** <br>(ตัวกลางแค่เก็บข้อมูล Consumer ต้องฉลาดดึงเอง) |
| **การส่งข้อมูล** | **Push-based** (ดันข้อมูลไปหา Consumer) | **Pull-based** (Consumer ดึงข้อมูลมาเอง) |
| **ประสิทธิภาพ** | Low Latency (เร็วมากต่อข้อความ) แต่ Throughput ต่ำกว่า | High Throughput (รองรับปริมาณสูงมาก) แต่ Latency สูงกว่านิดหน่อย |
| **การเก็บข้อมูล** | ข้อมูลหายไปเมื่อถูกทำงานเสร็จ (Transient) | ข้อมูลเก็บไว้ตามระยะเวลา (Retention) แม้ถูกอ่านแล้ว |
| **Routing** | ซับซ้อนและยืดหยุ่นมาก (Direct, Topic, Fanout, Header) | เรียบง่าย (เน้น Partition) |
| **ลำดับข้อมูล** | รับประกันลำดับในระดับ Queue | รับประกันลำดับเฉพาะใน Partition เดียวกัน |

-----

### 2\. เจาะลึกความแตกต่างหลัก

#### **RabbitMQ (The Mailman - บุรุษไปรษณีย์)**

คิดภาพเหมือนไปรษณีย์ คุณส่งจดหมาย (Message) ไปที่ศูนย์คัดแยก (Exchange) แล้วศูนย์จะดูจ่าหน้าซองเพื่อส่งลงกล่อง (Queue) ที่ถูกต้อง เมื่อผู้รับ (Consumer) มารับจดหมายไปแล้ว จดหมายนั้นจะ **"หายไป"** จากกล่อง

  * **จุดเด่น:**
      * **Complex Routing:** เก่งมากเรื่องเงื่อนไขการส่ง เช่น ส่งข้อความนี้ไป Service A และ B แต่ถ้า Error ให้ส่งไป C ความสามารถนี้อยู่ที่ตัว RabbitMQ เอง
      * **Priority Queue:** จัดลำดับความสำคัญข้อความด่วนได้
      * **Acknowledgements:** มีระบบยืนยันที่แข็งแรงว่า "ฉันได้รับของแล้ว ลบออกได้เลย"

#### **Apache Kafka (The Log Recorder - สมุดบันทึกเหตุการณ์)**

คิดภาพเหมือนสมุดบันทึก (Log) ขนาดใหญ่ ข้อมูล (Message) จะถูกเขียนต่อท้ายไปเรื่อยๆ ผู้รับ (Consumer) ต้องจำเองว่าอ่านถึงบรรทัดไหนแล้ว (Offset) การที่คนหนึ่งอ่านข้อความไปแล้ว **"ไม่ได้ทำให้ข้อความหายไป"** คนอื่นยังมาอ่านซ้ำได้ จนกว่าจะหมดเวลาเก็บรักษา (Retention Period)

  * **จุดเด่น:**
      * **High Throughput:** รองรับการเขียนข้อมูลหลักล้าน Record ต่อวินาทีได้สบายๆ
      * **Replayability:** สามารถย้อนกลับไปอ่านข้อมูลเก่าๆ ได้ (เช่น ระบบล่ม ต้องการประมวลผลข้อมูลเมื่อวานใหม่)
      * **Scalability:** ขยายระบบง่ายมาก (Horizontal Scaling) ด้วยการเพิ่ม Partition

-----

### 3\. เมื่อไหร่ควรใช้อะไร?

#### **เลือก RabbitMQ เมื่อ:**

1.  **ต้องการ Routing ที่ซับซ้อน:** ต้องการส่งข้อความไปยังผู้รับหลายกลุ่มด้วยเงื่อนไขที่ต่างกัน (Topics, Headers exchanges)
2.  **งานแบบ Long-running Tasks:** เช่น การประมวลผลรูปภาพ, การแปลงไฟล์ PDF ที่ทำเสร็จทีละงานแล้วจบไป
3.  **ระบบ Legacy หรือ Microservices ทั่วไป:** ที่ต้องการแค่การสื่อสารระหว่าง Service แบบ Request/Reply หรือ Fire-and-forget ที่ไม่ซับซ้อน
4.  **ต้องการ Priority:** ต้องการให้งานด่วนถูกทำก่อน

#### **เลือก Kafka เมื่อ:**

1.  **Event Sourcing / Stream Processing:** ต้องการเก็บประวัติการเปลี่ยนแปลงของข้อมูล หรือต้องการวิเคราะห์ข้อมูลแบบ Real-time (เช่น Fraud Detection, User Activity Tracking)
2.  **High Volume Data:** ข้อมูล Log, ข้อมูลจาก IoT Sensor, ข้อมูล Clickstream ที่ไหลเข้ามาเยอะและเร็วมาก
3.  **ต้องการเก็บข้อมูลถาวรชั่วคราว (Retention):** ต้องการให้ผู้รับหลายๆ ระบบ มาดึงข้อมูลชุดเดียวกันไปใช้คนละเวลา หรือย้อนกลับมาอ่านใหม่ได้
4.  **Microservices Orchestration:** ใช้เป็น Central Event Bus ที่ทุก Service มา Subscribe เหตุการณ์ที่เกิดขึ้น

-----

### 4\. สรุปภาพรวม

  * ถ้าโจทย์คือ **"ฝากส่งงานให้หน่อย เดี๋ยวฉันว่างแล้วจะมาเอา"** -\> ใช้ **RabbitMQ**
  * ถ้าโจทย์คือ **"บันทึกทุกอย่างที่เกิดขึ้นไว้ให้หน่อย เดี๋ยวฉันจะมาไล่อ่านทีหลัง (หรืออ่านตอนนี้เลยก็ได้)"** -\> ใช้ **Kafka**

**คำแนะนำเพิ่มเติม:** ในสถาปัตยกรรมใหญ่ๆ เรามักจะ **ใช้ร่วมกัน** ครับ เช่น ใช้ Kafka รับข้อมูลดิบมหาศาลจากภายนอกเข้ามา (Ingest) แล้วคัดกรองเฉพาะข้อมูลสำคัญส่งต่อให้ RabbitMQ เพื่อจ่ายงานให้ Worker นำไปประมวลผลต่อครับ
